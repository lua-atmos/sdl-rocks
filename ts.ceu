local SHIP_FRAMES      = 4
local SHIP_ACC_DIV     = 10
local SHIP_VEL_MAX  = {WIN.w/2.5, WIN.h/2.5}
local SHOT_DIM      = {WIN.w/50, WIN.h/100}
local SHOT_COLOR    = {0xFF,0xFF,0x88,0xFF}
local METEOR_FRAMES = 6
local METEOR_AWAIT  = 5000

function random_signal ()
    return (random.bool() and 1) or -1
end

function Meteor ()
    local path = "imgs/meteor.gif"
    local y_sig = random_signal()

    local vx = (1 + (random.int(WIN.w/5))) * random_signal()
    local vy = (1 + (random.int(WIN.h/5))) * y_sig

    local dim = pico.get.image.size(path)
    local w = dim.w / METEOR_FRAMES
    local dx = 0

    local x = random.int(WIN.w)
    local y = (y_sig == 1) and 0 or WIN.h
    set pub = {{{x,y}, {w,dim.h}}}

    par_or {
        local dt = random.int(1, METEOR_AWAIT)
        await <dt:ms>
        par_or {
            await spawn Move_T(pub.rect, [vx,vy])
        } with {
            await(:collided)
            pico.output.sound("snds/meteor.wav")
        }
    } with {
        every :Pico.Draw {
            pico.set.image.crop([[dx,0],[w,dim.h]])
            pico.output.draw.image(pub.rect.pos, path)
        }
    } with {
        local v = ((vx**2) + (vy**2)) ** (1/2)
        local x = 0
        every :Pico.Frame {
            x = x + ((v * it.ms) / 1000)
            dx = (x % dim.w) - (x % pub.rect.dim.w)
        }
    }
    ;;pub
end)

function Shot (tp, pos, vy)
    pico.output.sound("snds/shot.wav")
    set pub = tag(tp, [[pos, SHOT_DIM]])
    par_or {
        await(:collided)
    } with {
        local sig = if tp==:T.Shot.L => 1 => -1
        await spawn Move_T(pub.rect, [(WIN.w/3)*sig, vy])
    } with {
        every :Pico.Draw {
            pico.set.color.draw(SHOT_COLOR)
            pico.output.draw.rect(pub.rect)
        }
    }
    ;;pub
end

function Ship (tp, pos:XY, ctl:Control, shots, path)
    local dim:WH = pico.get.image.size(path)
    local vel:XY = [0,0]
    local dy = dim.h / SHIP_FRAMES
    set pub = tag(tp, [[pos, [dim.w,dy]]])

    local acc:XY = [0,0]
    local key
    spawn {
        par {
            every :Pico.Key.Dn {
                match it.key {
                    == ctl.mov.left  => acc.x = -WIN.w/SHIP_ACC_DIV
                    == ctl.mov.right => acc.x =  WIN.w/SHIP_ACC_DIV
                    == ctl.mov.up    => acc.y = -WIN.h/SHIP_ACC_DIV
                    == ctl.mov.down  => acc.y =  WIN.h/SHIP_ACC_DIV
                    == ctl.shot      =>
                        (spawn Shot(tp', copy(pos), vel.y) in shots) where {
                            local tp' = ((tp == :T.Ship.L) and :T.Shot.L) or :T.Shot.R
                        }
                }
                key = it.key
            }
        } with {
            every :Pico.Key.Up {
                key = nil
                acc = [0,0]
            }
        }
    }

    par_or {
        await(:collided)
    } with {
        every :Pico.Draw {
            pico.set.image.crop([[0,frame*dy],[dim.w,dy]])
                where {
                    local frame = match key {
                        == ctl.mov.left  => ((tp==:T.Ship.L) and 0) or 1
                        == ctl.mov.right => ((tp==:T.Ship.R) and 0) or 1
                        == ctl.mov.up    => 2
                        == ctl.mov.down  => 3
                        else => 0
                    }
                }
            pico.output.draw.image(pos, path)
        }
    } with {
        every :Pico.Frame {
            local dt = it.ms / 1000
            vel.x = math.between(-SHIP_VEL_MAX.x, vel.x+(acc.x*dt), SHIP_VEL_MAX.x)
            vel.y = math.between(-SHIP_VEL_MAX.y, vel.y+(acc.y*dt), SHIP_VEL_MAX.y)
            pos.x = if tp == :T.Ship.L
                => math.between(0, pos.x+(vel.x*dt), WIN.w/2)
                => math.between(WIN.w/2, pos.x+(vel.x*dt), WIN.w)
            pos.y = math.between(0, pos.y+(vel.y*dt), WIN.h)
        }
    }

    pico.output.sound("snds/explosion.wav")
    watching <150:ms> {
        local d = dy / 2;
        par {
            every :Pico.Frame {
                d = d + (((40*d)*it.ms)/1000)
            }
        } with {
            every :Pico.Draw {
                pico.set.color.draw([0xFF,0x00,0x00,0xFF])
                pico.output.draw.oval([pos,[d,d]])
            }
        }
    }
end
